import time
import re
from decimal import Decimal
from fastapi import APIRouter, HTTPException

from .schemas import ChatRequest, ChatResponse
from .deps import get_core, get_store
from core.config import settings
from llm.chain import looks_like_followup
from memory.models import SessionState

router = APIRouter()

def get_business_unit_name(unit_id: str) -> str:
    """
    Helper function to get business unit name from dim_business_unit table.
    Returns the business unit name or a fallback if not found.
    """
    if not unit_id:
        return "All Units"
    
    from db.engine import db
    try:
        query = f'''
        SELECT "strBusinessUnitName" 
        FROM dim_business_unit 
        WHERE "Unit_Id" = '{unit_id}'
        LIMIT 1
        '''
        try:
            db_result = db.run(query)
            if not db_result or db_result.strip() == '':
                result = []
            else:
                result = eval(db_result)
        except (SyntaxError, ValueError) as e:
            print(f"Error parsing business unit query: {e}")
            result = []
        
        if result and len(result) > 0:
            return result[0][0]
        return f"Unit {unit_id}"
    except Exception as e:
        print(f"Error fetching business unit name: {e}")
        return f"Unit {unit_id}"

def is_conversational(message: str) -> bool:
    """Detect greetings, thanks, and other non-analytical messages."""
    msg = message.strip().lower()
    
    # Greetings
    if re.match(r'^(hi|hello|hey|good morning|good afternoon|good evening|greetings)[\s!.]*$', msg):
        return True
    
    # Thanks/acknowledgments
    if re.match(r'^(thanks|thank you|ok|okay|got it|understood|great|perfect|awesome|cool)[\s!.]*$', msg):
        return True
    
    # Questions about the system itself
    if any(phrase in msg for phrase in ['who are you', 'what can you do', 'how do you work', 'help me']):
        return True
    
    return False

def get_conversational_response(message: str, has_context: bool) -> str:
    """Generate appropriate conversational responses."""
    msg = message.strip().lower()
    
    # Greetings
    if re.match(r'^(hi|hello|hey)', msg):
        return "Hello! I'm your sales analytics assistant. I can help you analyze delivery data, customer trends, and business insights. What would you like to know?"
    
    # Thanks
    if 'thank' in msg:
        return "You're welcome! Let me know if you need anything else."
    
    # Acknowledgments
    if msg in ['ok', 'okay', 'got it', 'understood', 'great', 'perfect', 'awesome', 'cool']:
        return "Great! Feel free to ask me anything about your sales data."
    
    # System questions
    if 'who are you' in msg:
        return "I'm your AI sales analytics assistant. I can answer questions about deliveries, customers, trends, and provide insights based on your data."
    
    if 'what can you do' in msg or 'help' in msg:
        return """I can help you with:
- **Data queries**: "What are the top 10 customers?" or "How many deliveries in 2025?"
- **Trends**: "Show me monthly sales trends" or "Compare Q1 to Q2"
- **Analysis**: "Why did sales increase?" or "Which regions are growing?"
- **Recommendations**: "How can we improve retention?" or "What should we focus on?"

Just ask me anything about your sales and delivery data!"""
    
    return "I'm here to help with your sales analytics. What would you like to know?"

def is_elaboration_request(message: str) -> bool:
    """Detect when user wants more details about the previous answer."""
    msg = message.strip().lower()
    
    # Direct elaboration requests
    elaboration_patterns = [
        r'^(explain|tell me|can you|could you)\s+(more|further|in detail)',
        r'^(more|further)\s+(details?|info|information|explanation)',
        r'^elaborate',
        r'^go on',
        r'^continue',
        r'what (do you mean|does (this|that) mean)',
        r'why is (this|that)',
        r'how (does|did) (this|that)',
    ]
    
    for pattern in elaboration_patterns:
        if re.search(pattern, msg):
            return True
    
    # Short elaboration requests
    if msg in ['more?', 'more', 'explain', 'why?', 'how?', 'tell me more', 'can you explain more?']:
        return True
    
    return False

def is_analytical_question(message: str) -> bool:
    """Detect complex analytical questions that benefit from multi-step reasoning."""
    msg = message.strip().lower()
    
    # Analytical question patterns
    analytical_patterns = [
        r'\bwhy\s+(did|is|are|was|were|does|do|has|have)',
        r'\bhow\s+(can|could|should|did|does|do)',
        r'\bexplain\s+(why|how|the)',
        r'\bwhat\s+(caused|drives|explains)',
        r'\bwhat.*reason',
        r'\broot\s+cause',
    ]
    
    for pattern in analytical_patterns:
        if re.search(pattern, msg):
            return True
    
    return False


@router.post("/v1/chat", response_model=ChatResponse)
def chat(req: ChatRequest) -> ChatResponse:
    core = get_core()
    store = get_store()
    t0 = time.time()

    state = store.get(req.session_id)
    
    # Handle conversational messages (greetings, thanks, etc.)
    if is_conversational(req.message):
        answer = get_conversational_response(req.message, state.last_question is not None)
        return ChatResponse(
            session_id=req.session_id,
            mode="conversational",
            answer=answer,
            meta={"latency_ms": int((time.time()-t0)*1000)}
        )
    
    # Handle elaboration requests (explain more, tell me more, etc.)
    if is_elaboration_request(req.message) and state.last_descriptive:
        answer = core.elaborate(
            last_question=state.last_question or "",
            last_answer=state.last_descriptive,
            last_result=state.last_result or "",
            user_request=req.message
        )
        return ChatResponse(
            session_id=req.session_id,
            mode="elaboration",
            answer=answer,
            used_question=state.last_question,
            meta={"latency_ms": int((time.time()-t0)*1000)}
        )
    
    question = req.message

    # Contextualize follow-up questions
    if state.last_question and looks_like_followup(req.message):
        question = core.contextualize(
            last_question=state.last_question,
            entity_type=state.entity_type,
            entities=state.entities,
            metric=state.metric,
            user_message=req.message
        )

    try:
        # Run SQL query
        out = core.run_sql_from_question(question)
        
        # Generate descriptive answer
        desc = core.descriptive(out)
        
        # Use multi-step reasoning for analytical questions
        if is_analytical_question(req.message):
            desc = core.analyze_with_reasoning(
                question=out["question"],
                result=out["result"],
                descriptive_answer=desc
            )
        
        # Extract entities for context
        ent = core.extract_entities(out["query"], out["result"])
        
        # Update session state
        new_state = SessionState(
            last_question=out["question"],
            last_sql=out["query"],
            last_result=out["result"],
            last_descriptive=desc,
            entity_type=ent.get("entity_type", "unknown"),
            entities=ent.get("entities", []) or [],
            metric=ent.get("metric", "unknown"),
        )
        store.set(req.session_id, new_state)

        return ChatResponse(
            session_id=req.session_id,
            mode="descriptive",
            answer=desc,
            used_question=out["question"],
            sql=out["query"] if (req.debug or settings.DEBUG_RETURN_SQL) else None,
            meta={
                "latency_ms": int((time.time()-t0)*1000),
                "entity_type": new_state.entity_type,
                "entities": new_state.entities[:3],
                "metric": new_state.metric
            }
        )
    except Exception as e:
        # If SQL fails, try a general conversational answer
        # This handles general questions like "How to improve sales?" that don't map to SQL
        try:
            general_answer = core.general_response(req.message)
            return ChatResponse(
                session_id=req.session_id,
                mode="general",
                answer=general_answer,
                meta={"latency_ms": int((time.time()-t0)*1000)}
            )
        except Exception:
             # If even general chat fails, revert to error
            raise HTTPException(status_code=400, detail=str(e))

@router.get("/v1/units")
def get_units():
    """Get list of unique Unit IDs with business unit names."""
    from db.engine import db
    try:
        query = '''
        SELECT DISTINCT 
            d."Unit_ID" as unit_id,
            COALESCE(b."strBusinessUnitName", 'Unit ' || d."Unit_ID") as business_unit_name
        FROM delivery_data d
        LEFT JOIN dim_business_unit b ON d."Unit_ID" = b."Unit_Id"
        WHERE d."Unit_ID" IS NOT NULL
        ORDER BY d."Unit_ID"
        '''
        results = eval(db.run(query))
        # Return list of dicts with unit_id and business_unit_name
        return [{"unit_id": str(r[0]), "business_unit_name": r[1]} for r in results]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/v1/health")
def health():
    return {"status": "ok"}

@router.get("/top-customers-2025")
def get_top_customers(unit_id: str = None):
    """Get top 10 customers by revenue for 2025."""
    from db.engine import db
    try:
        where_clause = 'WHERE EXTRACT(YEAR FROM "Delivery_Date") = 2025 AND "Customer_Name" IS NOT NULL'
        if unit_id:
            where_clause += f" AND \"Unit_ID\" = '{unit_id}'"

        query = f'''
        SELECT 
            "Customer_Name",
            ROUND(CAST(SUM("Delivery_value") AS NUMERIC), 2) as total_revenue
        FROM delivery_data
        {where_clause}
        GROUP BY "Customer_Name"
        ORDER BY total_revenue DESC
        LIMIT 10
        '''
        results = eval(db.run(query))
        return [
            {"Customer_Name": r[0], "total_revenue": float(r[1])}
            for r in results
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/top-territories-2025")
def get_top_territories(unit_id: str = None):
    """Get top 10 territories by revenue for 2025."""
    from db.engine import db
    try:
        where_clause = 'WHERE EXTRACT(YEAR FROM "Delivery_Date") = 2025 AND "Transport_Zone_name" IS NOT NULL'
        if unit_id:
            where_clause += f" AND \"Unit_ID\" = '{unit_id}'"

        query = f'''
        SELECT 
            "Transport_Zone_name",
            ROUND(CAST(SUM("Delivery_value") AS NUMERIC), 2) as total_revenue
        FROM delivery_data
        {where_clause}
        GROUP BY "Transport_Zone_name"
        ORDER BY total_revenue DESC
        LIMIT 10
        '''
        results = eval(db.run(query))
        return [
            {"Transport_Zone_name": r[0], "total_revenue": float(r[1])}
            for r in results
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/v1/regional-insights")
def get_regional_insights(unit_id: str = None, month: str = None):
    """Get regional sales data with AI-powered insights."""
    from db.engine import db
    
    try:
        # Month filtering logic
        month_filter = ""
        target_month = month
        
        if not target_month:
            # If no month provided, get the latest month from DB
            latest_month_query = 'SELECT MAX(TO_CHAR("Delivery_Date", \'YYYY-MM\')) FROM delivery_data'
            latest_month_result = eval(db.run(latest_month_query))
            if latest_month_result and latest_month_result[0][0]:
                target_month = latest_month_result[0][0]

        if target_month:
            month_filter = f"AND TO_CHAR(\"Delivery_Date\", 'YYYY-MM') = '{target_month}'"

        where_clause = 'WHERE "Transport_Zone_name" IS NOT NULL'
        if unit_id:
            where_clause += f" AND \"Unit_ID\" = '{unit_id}'"

        # Query regional sales data
        query = f'''
        SELECT 
            "Transport_Zone_name" AS region,
            COUNT(*) AS order_count,
            ROUND(CAST(SUM("Delivery_Qty") AS NUMERIC), 2) AS total_delivery_qty,
            ROUND(CAST(SUM("Delivery_value") AS NUMERIC), 2) AS total_delivery_value
        FROM delivery_data
        {where_clause}
        {month_filter}
        GROUP BY "Transport_Zone_name"
        ORDER BY total_delivery_qty DESC
        LIMIT 10
        '''
        
        result = db.run(query)
        
        # Parse results
        regional_data = []
        total_qty = 0
        
        # Handle potential empty result safely
        rows = eval(result) if result else []
        
        for row in rows:
            qty = float(row[2])
            total_qty += qty
            regional_data.append({
                "region": row[0],
                "order_count": row[1],
                "total_delivery_qty": qty,
                "total_delivery_value": float(row[3]),
                "share_percentage": 0
            })
            
        if not regional_data:
             return {
                "business_unit_name": get_business_unit_name(unit_id),
                "total_delivery_qty": 0,
                "top": [],
                "bottom": [],
                "regional_data": [],
                "ai_insights": "No data available for the selected period."
            }
        
        # Calculate share percentages
        for region in regional_data:
            region["share_percentage"] = round((region["total_delivery_qty"] / total_qty) * 100, 2) if total_qty > 0 else 0
        
        # Generate AI insights
        core = get_core()
        if total_qty > 0:
            ai_insights = core.analyze_regional_performance(regional_data[:5])
        else:
            ai_insights = "Insufficient data for analysis."
        
        # Add compatibility fields
        for region in regional_data:
            region["name"] = region["region"]
            region["share_pct"] = region["share_percentage"]
        
        return {
            "business_unit_name": get_business_unit_name(unit_id),
            "total_delivery_qty": total_qty,
            "top": regional_data[:5],
            "bottom": regional_data[-3:] if len(regional_data) > 5 else [],
            "regional_data": regional_data,
            "ai_insights": ai_insights
        }
    
    except Exception as e:
        print(f"Error in regional insights: {str(e)}")
        return {
            "business_unit_name": get_business_unit_name(unit_id),
            "total_delivery_qty": 0,
            "top": [],
            "bottom": [],
            "regional_data": [],
            "ai_insights": "Error retrieving regional data."
        }

@router.get("/v1/sales-metrics")
def get_sales_metrics(unit_id: str = None, month: str = None):
    """Get total sales revenue and quantity metrics with AI insights.
    
    Args:
        unit_id: Optional business unit filter
        month: Optional month filter in YYYY-MM format (e.g., "2025-12")
    """
    from db.engine import db
    
    try:
        unit_filter = f" AND \"Unit_ID\" = '{unit_id}'" if unit_id else ""
        
        # If no month specified, get the latest available month
        if not month:
            latest_month_query = f'''
            SELECT TO_CHAR("Delivery_Date", 'YYYY-MM') as month
            FROM delivery_data
            WHERE "Delivery_Date" IS NOT NULL {unit_filter}
            ORDER BY "Delivery_Date" DESC
            LIMIT 1
            '''
            latest_result = eval(db.run(latest_month_query))
            month = latest_result[0][0] if latest_result else "2025-12"
        
        # Parse year and month from the month string
        year, month_num = month.split('-')
        
        # Current Month (or selected month)
        current_query = f'''
        SELECT 
            COUNT(*) as order_count,
            ROUND(CAST(SUM("Delivery_Qty") AS NUMERIC), 2) as total_qty,
            ROUND(CAST(SUM("Delivery_value") AS NUMERIC), 2) as total_revenue
        FROM delivery_data
        WHERE EXTRACT(YEAR FROM "Delivery_Date") = {year}
          AND EXTRACT(MONTH FROM "Delivery_Date") = {month_num}
          {unit_filter}
        '''
        
        # YTD
        ytd_query = f'''
        SELECT 
            COUNT(*) as order_count,
            ROUND(CAST(SUM("Delivery_Qty") AS NUMERIC), 2) as total_qty,
            ROUND(CAST(SUM("Delivery_value") AS NUMERIC), 2) as total_revenue
        FROM delivery_data
        WHERE EXTRACT(YEAR FROM "Delivery_Date") = 2025
        {unit_filter}
        '''
        
        # Last 12 Months
        trend_query = f'''
        SELECT 
            TO_CHAR("Delivery_Date", 'YYYY-MM') as month,
            COUNT(*) as order_count,
            ROUND(CAST(SUM("Delivery_Qty") AS NUMERIC), 2) as total_qty,
            ROUND(CAST(SUM("Delivery_value") AS NUMERIC), 2) as total_revenue
        FROM delivery_data
        WHERE "Delivery_Date" IS NOT NULL 
        {unit_filter}
        GROUP BY TO_CHAR("Delivery_Date", 'YYYY-MM')
        ORDER BY month DESC
        LIMIT 12
        '''
        
        # Execute queries
        current_result = eval(db.run(current_query))[0]
        ytd_result = eval(db.run(ytd_query))[0]
        trend_result = eval(db.run(trend_query))
        
        # Format results
        current_month = {
            "month": month,
            "order_count": current_result[0] or 0,
            "qty": float(current_result[1] or 0),
            "revenue": float(current_result[2] or 0)
        }
        
        ytd = {
            "year": 2025,
            "order_count": ytd_result[0] or 0,
            "qty": float(ytd_result[1] or 0),
            "revenue": float(ytd_result[2] or 0)
        }
        
        last_12_months = []
        for row in trend_result:
            last_12_months.append({
                "month": row[0],
                "order_count": row[1] or 0,
                "qty": float(row[2] or 0),
                "revenue": float(row[3] or 0)
            })
        
        # Generate AI insights
        core = get_core()
        ai_insights = core.analyze_sales_metrics(current_month, ytd, last_12_months)
        
        return {
            "business_unit_name": get_business_unit_name(unit_id),
            "current_month": current_month,
            "ytd": ytd,
            "last_12_months": last_12_months,
            "ai_insights": ai_insights
        }
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/v1/b2b-b2c-mix")
def get_b2b_b2c_mix(unit_id: str = None, month: str = None):
    """Get B2B vs B2C sales mix with AI insights."""
    from db.engine import db
    
    try:
        unit_filter = f" AND \"Unit_ID\" = '{unit_id}'" if unit_id else ""

        # Query sales by customer type
        # If no month specified, get the latest available month
        if not month:
            latest_month_query = f'''
            SELECT TO_CHAR("Delivery_Date", 'YYYY-MM') as month
            FROM delivery_data
            WHERE "Delivery_Date" IS NOT NULL {unit_filter}
            ORDER BY "Delivery_Date" DESC
            LIMIT 1
            '''
            latest_result = eval(db.run(latest_month_query))
            month = latest_result[0][0] if latest_result else "2025-12"
        
        # Parse year and month
        year, month_num = month.split('-')

        query = f'''
        SELECT 
            "strCustomerType" as customer_type,
            COUNT(*) as order_count,
            ROUND(CAST(SUM("Delivery_Qty") AS NUMERIC), 2) as total_qty,
            ROUND(CAST(SUM("Delivery_value") AS NUMERIC), 2) as total_revenue
        FROM delivery_data
        WHERE "strCustomerType" IS NOT NULL
          AND EXTRACT(YEAR FROM "Delivery_Date") = {year}
          AND EXTRACT(MONTH FROM "Delivery_Date") = {month_num}
        {unit_filter}
        GROUP BY "strCustomerType"
        '''
        
        try:
            db_result = db.run(query)
            if not db_result or db_result.strip() == '':
                result = []
            else:
                result = eval(db_result)
        except (SyntaxError, ValueError) as e:
            print(f"Error parsing B2B/B2C query: {e}")
            result = []
        
        # Classify and aggregate
        b2b_orders = 0
        b2b_qty = 0.0
        b2b_revenue = 0.0
        b2c_orders = 0
        b2c_qty = 0.0
        b2c_revenue = 0.0
        
        for row in result:
            customer_type = row[0]
            orders = row[1]
            qty = float(row[2])
            revenue = float(row[3])
            
            # B2B = B2B + Distributor, B2C = Dealer
            if customer_type in ['B2B', 'Distributor']:
                b2b_orders += orders
                b2b_qty += qty
                b2b_revenue += revenue
            else:  # Dealer
                b2c_orders += orders
                b2c_qty += qty
                b2c_revenue += revenue
        
        total_revenue = b2b_revenue + b2c_revenue
        total_qty = b2b_qty + b2c_qty
        
        # Calculate percentages
        b2b_percentage = (b2b_revenue / total_revenue * 100) if total_revenue > 0 else 0
        b2c_percentage = (b2c_revenue / total_revenue * 100) if total_revenue > 0 else 0
        
        b2b_data = {
            "order_count": b2b_orders,
            "qty": b2b_qty,
            "revenue": b2b_revenue,
            "percentage": round(b2b_percentage, 2)
        }
        
        b2c_data = {
            "order_count": b2c_orders,
            "qty": b2c_qty,
            "revenue": b2c_revenue,
            "percentage": round(b2c_percentage, 2)
        }
        
        # Generate AI insights
        core = get_core()
        ai_insights = core.analyze_b2b_b2c_mix(b2b_data, b2c_data)
        
        return {
            "month": month,
            "b2b": b2b_data,
            "b2c": b2c_data,
            "total_revenue": total_revenue,
            "total_qty": total_qty,
            "ai_insights": ai_insights
        }
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/v1/credit-sales-ratio")
def get_credit_sales_ratio(unit_id: str = None, month: str = None):
    """Get credit vs cash sales ratio with AI insights."""
    from db.engine import db
    
    try:
        unit_filter = f" AND \"Unit_ID\" = '{unit_id}'" if unit_id else ""

        # If no month specified, get the latest available month
        if not month:
            latest_month_query = f'''
            SELECT TO_CHAR("Delivery_Date", 'YYYY-MM') as month
            FROM delivery_data
            WHERE "Delivery_Date" IS NOT NULL {unit_filter}
            ORDER BY "Delivery_Date" DESC
            LIMIT 1
            '''
            try:
                db_result = db.run(latest_month_query)
                if not db_result or db_result.strip() == '':
                    latest_result = []
                else:
                    latest_result = eval(db_result)
            except (SyntaxError, ValueError) as e:
                print(f"Error parsing credit ratio latest month: {e}")
                latest_result = []
            month = latest_result[0][0] if latest_result else "2025-12"
        
        # Parse year and month
        year, month_num = month.split('-')

        # Query sales by payment type (credit vs cash)
        query = f'''
        SELECT 
            CASE 
                WHEN "Due_Amount" > 0 THEN 'Credit'
                ELSE 'Cash'
            END as payment_type,
            COUNT(*) as order_count,
            ROUND(CAST(SUM("Delivery_Qty") AS NUMERIC), 2) as total_qty,
            ROUND(CAST(SUM("Delivery_value") AS NUMERIC), 2) as total_revenue
        FROM delivery_data
        WHERE "Delivery_Date" IS NOT NULL
          AND EXTRACT(YEAR FROM "Delivery_Date") = {year}
          AND EXTRACT(MONTH FROM "Delivery_Date") = {month_num}
        {unit_filter}
        GROUP BY CASE WHEN "Due_Amount" > 0 THEN 'Credit' ELSE 'Cash' END
        '''
        
        try:
            db_result = db.run(query)
            if not db_result or db_result.strip() == '':
                result = []
            else:
                result = eval(db_result)
        except (SyntaxError, ValueError) as e:
            print(f"Error parsing credit sales ratio query: {e}")
            result = []
        
        # Parse results
        credit_orders = 0
        credit_qty = 0.0
        credit_revenue = 0.0
        cash_orders = 0
        cash_qty = 0.0
        cash_revenue = 0.0
        
        for row in result:
            payment_type = row[0]
            orders = row[1]
            qty = float(row[2])
            revenue = float(row[3])
            
            if payment_type == 'Credit':
                credit_orders = orders
                credit_qty = qty
                credit_revenue = revenue
            else:
                cash_orders = orders
                cash_qty = qty
                cash_revenue = revenue
        
        total_revenue = credit_revenue + cash_revenue
        
        # Calculate percentages
        credit_percentage = (credit_revenue / total_revenue * 100) if total_revenue > 0 else 0
        cash_percentage = (cash_revenue / total_revenue * 100) if total_revenue > 0 else 0
        
        credit_data = {
            "order_count": credit_orders,
            "qty": credit_qty,
            "revenue": credit_revenue,
            "percentage": round(credit_percentage, 2)
        }
        
        cash_data = {
            "order_count": cash_orders,
            "qty": cash_qty,
            "revenue": cash_revenue,
            "percentage": round(cash_percentage, 2)
        }
        
        # Generate AI insights
        core = get_core()
        ai_insights = core.analyze_credit_ratio(credit_data, cash_data)
        
        return {
            "month": month,
            "credit": credit_data,
            "cash": cash_data,
            "total_revenue": total_revenue,
            "ai_insights": ai_insights
        }
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/v1/credit-sales-ratio-by-channel")
def get_credit_sales_ratio_by_channel(unit_id: str = None, month: str = None):
    """Get credit vs cash sales ratio breakdown by channel with AI insights."""
    from db.engine import db
    
    try:
        unit_filter = f" AND \"Unit_ID\" = '{unit_id}'" if unit_id else ""

        # If no month specified, get the latest available month
        if not month:
            latest_month_query = f'''
            SELECT TO_CHAR("Delivery_Date", 'YYYY-MM') as month
            FROM delivery_data
            WHERE "Delivery_Date" IS NOT NULL {unit_filter}
            ORDER BY "Delivery_Date" DESC
            LIMIT 1
            '''
            try:
                db_result = db.run(latest_month_query)
                if not db_result or db_result.strip() == '':
                    latest_result = []
                else:
                    latest_result = eval(db_result)
            except (SyntaxError, ValueError) as e:
                print(f"Error parsing channel credit latest month (api.py): {e}")
                latest_result = []
            month = latest_result[0][0] if latest_result else "2025-12"
        
        # Parse year and month
        year, month_num = month.split('-')

        # Query sales by channel and payment type
        query = f'''
        SELECT 
            "Channel_Name",
            CASE 
                WHEN "Due_Amount" > 0 THEN 'Credit'
                ELSE 'Cash'
            END as payment_type,
            COUNT(*) as order_count,
            ROUND(CAST(SUM("Delivery_Qty") AS NUMERIC), 2) as total_qty,
            ROUND(CAST(SUM("Delivery_value") AS NUMERIC), 2) as total_revenue
        FROM delivery_data
        WHERE "Delivery_Date" IS NOT NULL
          AND "Channel_Name" IS NOT NULL
          AND EXTRACT(YEAR FROM "Delivery_Date") = {year}
          AND EXTRACT(MONTH FROM "Delivery_Date") = {month_num}
        {unit_filter}
        GROUP BY "Channel_Name", CASE WHEN "Due_Amount" > 0 THEN 'Credit' ELSE 'Cash' END
        ORDER BY "Channel_Name", payment_type
        '''
        
        try:
            db_result = db.run(query)
            if not db_result or db_result.strip() == '':
                # No data for this month
                result = []
            else:
                result = eval(db_result)
        except (SyntaxError, ValueError) as e:
            # Handle eval errors gracefully
            print(f"Error parsing database result: {e}")
            print(f"DB Result: {db_result[:200] if db_result else 'None'}")
            result = []
        
        # Parse results and organize by channel
        channels_data = {}
        
        for row in result:
            channel_name = row[0]
            payment_type = row[1]
            orders = row[2]
            qty = float(row[3])
            revenue = float(row[4])
            
            if channel_name not in channels_data:
                channels_data[channel_name] = {
                    "channel_name": channel_name,
                    "credit": {"order_count": 0, "qty": 0.0, "revenue": 0.0},
                    "cash": {"order_count": 0, "qty": 0.0, "revenue": 0.0}
                }
            
            if payment_type == 'Credit':
                channels_data[channel_name]["credit"] = {
                    "order_count": orders,
                    "qty": qty,
                    "revenue": revenue
                }
            else:
                channels_data[channel_name]["cash"] = {
                    "order_count": orders,
                    "qty": qty,
                    "revenue": revenue
                }
        
        # Calculate percentages for each channel
        channels_list = []
        
        # First, calculate total revenue across all channels (credit + cash)
        total_credit_revenue = sum(data["credit"]["revenue"] for data in channels_data.values())
        total_cash_revenue = sum(data["cash"]["revenue"] for data in channels_data.values())
        total_revenue_all = total_credit_revenue + total_cash_revenue
        
        for channel_name, data in channels_data.items():
            # Calculate percentage of TOTAL SALES (not just credit or cash)
            # This way, if overall credit is 98%, all channel credit %s will sum to 98%
            credit_percentage = (data["credit"]["revenue"] / total_revenue_all * 100) if total_revenue_all > 0 else 0
            cash_percentage = (data["cash"]["revenue"] / total_revenue_all * 100) if total_revenue_all > 0 else 0
            
            # Also calculate individual channel ratio for reference
            channel_total = data["credit"]["revenue"] + data["cash"]["revenue"]
            credit_ratio = (data["credit"]["revenue"] / channel_total * 100) if channel_total > 0 else 0
            cash_ratio = (data["cash"]["revenue"] / channel_total * 100) if channel_total > 0 else 0
            
            data["credit"]["percentage"] = round(credit_percentage, 2)
            data["credit"]["ratio"] = round(credit_ratio, 2)
            data["cash"]["percentage"] = round(cash_percentage, 2)
            data["cash"]["ratio"] = round(cash_ratio, 2)
            data["total_revenue"] = channel_total
            
            channels_list.append(data)
        
        # Sort by total revenue descending
        channels_list.sort(key=lambda x: x["total_revenue"], reverse=True)
        
        # Generate AI insights
        core = get_core()
        ai_insights = core.analyze_channel_credit_ratio(channels_list)
        
        return {
            "month": month,
            "channels": channels_list,
            "ai_insights": ai_insights,
            "total_credit_revenue": total_credit_revenue,
            "total_cash_revenue": total_cash_revenue,
            "total_revenue": total_revenue_all,
            "message": "No data available for the selected month" if not channels_list else None
        }
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/v1/credit-sales-ratio-by-customer")
def get_credit_sales_ratio_by_customer(unit_id: str = None, month: str = None):
    """Get credit vs cash sales ratio breakdown by customer."""
    from db.engine import db
    
    try:
        unit_filter = f" AND \"Unit_ID\" = '{unit_id}'" if unit_id else ""

        # If no month specified, get the latest available month
        if not month:
            latest_month_query = f'''
            SELECT TO_CHAR("Delivery_Date", 'YYYY-MM') as month
            FROM delivery_data
            WHERE "Delivery_Date" IS NOT NULL {unit_filter}
            ORDER BY "Delivery_Date" DESC
            LIMIT 1
            '''
            try:
                db_result = db.run(latest_month_query)
                if not db_result or db_result.strip() == '':
                    latest_result = []
                else:
                    latest_result = eval(db_result)
            except (SyntaxError, ValueError) as e:
                print(f"Error parsing customer credit latest month (api.py): {e}")
                latest_result = []
            month = latest_result[0][0] if latest_result else "2025-12"
        
        # Parse year and month
        year, month_num = month.split('-')

        # Query sales by customer and payment type
        query = f'''
        SELECT 
            "Customer_ID",
            "Customer_Name",
            CASE 
                WHEN "Due_Amount" > 0 THEN 'Credit'
                ELSE 'Cash'
            END as payment_type,
            COUNT(*) as order_count,
            ROUND(CAST(SUM("Delivery_Qty") AS NUMERIC), 2) as total_qty,
            ROUND(CAST(SUM("Delivery_value") AS NUMERIC), 2) as total_revenue
        FROM delivery_data
        WHERE "Delivery_Date" IS NOT NULL
          AND "Customer_ID" IS NOT NULL
          AND "Customer_Name" IS NOT NULL
          AND EXTRACT(YEAR FROM "Delivery_Date") = {year}
          AND EXTRACT(MONTH FROM "Delivery_Date") = {month_num}
        {unit_filter}
        GROUP BY "Customer_ID", "Customer_Name", CASE WHEN "Due_Amount" > 0 THEN 'Credit' ELSE 'Cash' END
        ORDER BY "Customer_ID", payment_type
        '''
        
        try:
            db_result = db.run(query)
            if not db_result or db_result.strip() == '':
                # No data for this month
                result = []
            else:
                result = eval(db_result)
        except (SyntaxError, ValueError) as e:
            # Handle eval errors gracefully
            print(f"Error parsing database result: {e}")
            print(f"DB Result: {db_result[:200] if db_result else 'None'}")
            result = []
        
        # Parse results and organize by customer
        customers_data = {}
        
        for row in result:
            customer_id = row[0]
            customer_name = row[1]
            payment_type = row[2]
            orders = row[3]
            qty = float(row[4])
            revenue = float(row[5])
            
            if customer_id not in customers_data:
                customers_data[customer_id] = {
                    "customer_id": customer_id,
                    "customer_name": customer_name,
                    "credit": {"order_count": 0, "qty": 0.0, "revenue": 0.0},
                    "cash": {"order_count": 0, "qty": 0.0, "revenue": 0.0}
                }
            
            if payment_type == 'Credit':
                customers_data[customer_id]["credit"] = {
                    "order_count": orders,
                    "qty": qty,
                    "revenue": revenue
                }
            else:
                customers_data[customer_id]["cash"] = {
                    "order_count": orders,
                    "qty": qty,
                    "revenue": revenue
                }
        
        # Calculate percentages for each customer
        customers_list = []
        
        # First, calculate total revenue across all customers (credit + cash)
        total_credit_revenue = sum(data["credit"]["revenue"] for data in customers_data.values())
        total_cash_revenue = sum(data["cash"]["revenue"] for data in customers_data.values())
        total_revenue_all = total_credit_revenue + total_cash_revenue
        
        for customer_id, data in customers_data.items():
            # Calculate percentage of TOTAL SALES (not just credit or cash)
            # This way, if overall credit is 98%, all customer credit %s will sum to 98%
            credit_percentage = (data["credit"]["revenue"] / total_revenue_all * 100) if total_revenue_all > 0 else 0
            cash_percentage = (data["cash"]["revenue"] / total_revenue_all * 100) if total_revenue_all > 0 else 0
            
            # Also calculate individual customer ratio for reference
            customer_total = data["credit"]["revenue"] + data["cash"]["revenue"]
            credit_ratio = (data["credit"]["revenue"] / customer_total * 100) if customer_total > 0 else 0
            cash_ratio = (data["cash"]["revenue"] / customer_total * 100) if customer_total > 0 else 0
            
            data["credit"]["percentage"] = round(credit_percentage, 2)
            data["credit"]["ratio"] = round(credit_ratio, 2)
            data["cash"]["percentage"] = round(cash_percentage, 2)
            data["cash"]["ratio"] = round(cash_ratio, 2)
            data["total_revenue"] = customer_total
            
            customers_list.append(data)
        
        # Sort by total revenue descending
        customers_list.sort(key=lambda x: x["total_revenue"], reverse=True)
        
        return {
            "month": month,
            "customers": customers_list,
            "total_credit_revenue": total_credit_revenue,
            "total_cash_revenue": total_cash_revenue,
            "total_revenue": total_revenue_all,
            "message": "No data available for the selected month" if not customers_list else None
        }
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/v1/concentration-risk")
def get_concentration_risk(unit_id: str = None, month: str = None):
    """Get customer concentration risk metrics with AI insights."""
    from db.engine import db
    
    try:
        # Month filtering logic
        month_filter = ""
        target_month = month
        
        if not target_month:
            # If no month provided, get the latest month from DB
            latest_month_query = 'SELECT MAX(TO_CHAR("Delivery_Date", \'YYYY-MM\')) FROM delivery_data'
            latest_month_result = eval(db.run(latest_month_query))
            if latest_month_result and latest_month_result[0][0]:
                target_month = latest_month_result[0][0]

        if target_month:
            month_filter = f"AND TO_CHAR(\"Delivery_Date\", 'YYYY-MM') = '{target_month}'"
        
        unit_clause = f"AND \"Unit_ID\" = '{unit_id}'" if unit_id else ""
        
        # 1. Total Sales
        query_total = f'''
        SELECT CAST(SUM("Delivery_value") AS NUMERIC) as total_sales
        FROM delivery_data
        WHERE 1=1
        {unit_clause}
        {month_filter}
        '''
        total_result = eval(db.run(query_total))
        total_sales = float(total_result[0][0]) if total_result and total_result[0][0] is not None else 0.0
        
        # 2. Top 10 Customers
        query_top10 = f'''
        SELECT "Customer_Name", CAST(SUM("Delivery_value") AS NUMERIC) as customer_sales
        FROM delivery_data
        WHERE "Customer_Name" IS NOT NULL
        {unit_clause}
        {month_filter}
        GROUP BY "Customer_Name"
        ORDER BY customer_sales DESC
        LIMIT 10
        '''
        
        try:
            db_result = db.run(query_top10)
            if not db_result or db_result.strip() == '':
                top10_result = []
            else:
                top10_result = eval(db_result)
        except (SyntaxError, ValueError) as e:
            print(f"Error parsing concentration risk top10 query: {e}")
            top10_result = []
        
        top10_customers = []
        top10_sales_sum = 0.0
        
        if top10_result:
            for row in top10_result:
                name = row[0]
                sales = float(row[1]) if row[1] is not None else 0.0
                pct = (sales / total_sales) * 100 if total_sales > 0 else 0
                top10_sales_sum += sales
                top10_customers.append({
                    "name": name,
                    "revenue": sales,
                    "percentage": round(pct, 2)
                })
            
        concentration_ratio = (top10_sales_sum / total_sales * 100) if total_sales > 0 else 0
        
        # Prepare data for AI
        if top10_customers:
            top1_data = {
                "name": top10_customers[0]["name"],
                "pct": top10_customers[0]["percentage"]
            }
        else:
            top1_data = {"name": "None", "pct": 0}
        
        # Generate AI insights
        # Only generate insights if we have data, otherwise return empty
        ai_insights = ""
        if total_sales > 0:
            core = get_core()
            ai_insights = core.analyze_concentration_risk(concentration_ratio, top1_data)
        else:
            ai_insights = "No data available for the selected period."

        return {
            "concentration_ratio": round(concentration_ratio, 2),
            "total_revenue": total_sales,
            "top_10_revenue": top10_sales_sum,
            "top_10_customers": top10_customers,
            "ai_insights": ai_insights
        }

    except Exception as e:
        # Log error for debugging but don't crash the endpoint
        print(f"Error in concentration risk: {str(e)}")
        # Return empty structure instead of 500
        return {
            "concentration_ratio": 0,
            "total_revenue": 0,
            "top_10_revenue": 0,
            "top_10_customers": [],
            "ai_insights": "Error calculating concentration risk."
        }

@router.get("/v1/sales-growth")
def get_sales_growth(unit_id: str = None, month: str = None):
    """Get sales growth metrics (MoM) and trend data with AI insights."""
    from db.engine import db
    
    try:
        unit_filter = f" AND \"Unit_ID\" = '{unit_id}'" if unit_id else ""

        # Determine target month
        target_month_clause = ""
        current_month_str = month
        
        if not current_month_str:
             # Get latest month if not provided
            latest_month_query = 'SELECT MAX(TO_CHAR("Delivery_Date", \'YYYY-MM\')) FROM delivery_data'
            latest_month_result = eval(db.run(latest_month_query))
            if latest_month_result and latest_month_result[0][0]:
                current_month_str = latest_month_result[0][0]
        
        if current_month_str:
            # We want the selected month and the 12 months prior to it (total 13 for trend)
            target_month_clause = f" AND TO_CHAR(\"Delivery_Date\", 'YYYY-MM') <= '{current_month_str}'"

        # Query monthly sales
        query = f'''
        SELECT 
            TO_CHAR("Delivery_Date", 'YYYY-MM') as month,
            SUM("Delivery_value") as revenue
        FROM delivery_data
        WHERE "Delivery_Date" IS NOT NULL
        {unit_filter}
        {target_month_clause}
        GROUP BY month
        ORDER BY month DESC
        LIMIT 13
        '''
        
        result = eval(db.run(query))
        
        monthly_data = []
        for row in result:
            monthly_data.append({
                "month": row[0],
                "revenue": float(row[1])
            })
            
        # Check if the *selected* month (which should be first in list due to DESC sort) matches our target
        # If result is empty, or the first month isn't what we asked for (e.g. data gap), handle it.
        
        if not monthly_data:
             # Return empty structure meant for charts, not 404 to avoid breaking UI entirely if possible, 
             # but keeping 404 for consistency with previous behavior if that's preferred.
             # Previous code raised 404. Let's return structure with 0s to allow UI to show "No Data" gracefully.
             return {
                "current_month": {"month": current_month_str or "N/A", "revenue": 0},
                "prev_month": {"month": "N/A", "revenue": 0},
                "mom_growth": 0,
                "yoy_growth": None,
                "chart_data": [],
                "ai_insights": "No data available for this period."
            }

        # Current and Previous Month
        # Note: monthly_data[0] is the most recent in the window.
        current_month_data = monthly_data[0]
        
        # If the returned data's latest month isn't the one we requested (e.g. we asked for 2025-04 but max data is 2025-03),
        # strictly speaking for "filtering" we might want to return 0 for the requested month.
        # But for 'trend' extending back, it's tricky. 
        # Simpler approach: If we have specific month selected, and the top result isn't that month, it implies 0 sales for that month.
        # However, LIMIT 13 DESC on <= month means we just get the latest available ON OR BEFORE.
        # So we must verify if monthly_data[0]['month'] == current_month_str.
        
        if current_month_str and current_month_data['month'] != current_month_str:
            # The selected month has NO data. We insert it as 0.
            current_month_data = {"month": current_month_str, "revenue": 0}
            # The "previous" month for calculation would be the actual data[0] if it is the immediate predecessor? 
            # Or simplified: if current is 0, growth from prev is -100% (if prev exists).
            # Let's keep it simple: current is 0.
            prev_month_data = monthly_data[0] if monthly_data else {"month": "N/A", "revenue": 0}
             # But wait, if we requested Apr, and data returned Mar as top, then Apr is 0. 
             # Mar is prev.
        else:
             prev_month_data = monthly_data[1] if len(monthly_data) > 1 else {"month": "N/A", "revenue": 0}
        
        # Determine MoM Growth
        if prev_month_data['revenue'] > 0:
            mom_growth = ((current_month_data['revenue'] - prev_month_data['revenue']) / prev_month_data['revenue']) * 100
        else:
            mom_growth = 0 if current_month_data['revenue'] == 0 else 100 # 0 to positive is strictly infinite, usually capped or treated as 100%
            
        # Generate AI insights
        # Only analyze if we have some data context
        core = get_core()
        if current_month_data['revenue'] > 0 or (len(monthly_data) > 0 and monthly_data[0]['revenue'] > 0):
             ai_insights = core.analyze_sales_growth(current_month_data, prev_month_data, monthly_data)
        else:
             ai_insights = "No sales data available for growth analysis."
        
        # Reverse data for chart (oldest to newest)
        chart_data = monthly_data[::-1]
        
        return {
            "current_month": current_month_data,
            "prev_month": prev_month_data,
            "mom_growth": mom_growth,
            "yoy_growth": None, # Insufficient data for known period
            "chart_data": chart_data,
            "ai_insights": ai_insights
        }

    except Exception as e:
        print(f"Error in sales growth: {str(e)}")
        # Graceful failure
        return {
                "current_month": {"month": "Error", "revenue": 0},
                "prev_month": {"month": "N/A", "revenue": 0},
                "mom_growth": 0,
                "yoy_growth": None,
                "chart_data": [],
                "ai_insights": "Error calculating growth."
            }

@router.get("/v1/territory-performance")
def get_territory_performance(unit_id: str = None, month: str = None):
    """Get sales by territory and dealers (top and bottom) with AI insights."""
    from db.engine import db
    
    try:
        # Month filtering logic
        month_filter = ""
        target_month = month
        
        if not target_month:
            # If no month provided, get the latest month from DB
            latest_month_query = 'SELECT MAX(TO_CHAR("Delivery_Date", \'YYYY-MM\')) FROM delivery_data'
            latest_month_result = eval(db.run(latest_month_query))
            if latest_month_result and latest_month_result[0][0]:
                target_month = latest_month_result[0][0]

        if target_month:
            month_filter = f"AND TO_CHAR(\"Delivery_Date\", 'YYYY-MM') = '{target_month}'"
        
        unit_filter_clause = f" AND \"Unit_ID\" = '{unit_id}'" if unit_id else ""
    
        # 1. Territories (All, ordered by revenue)
        query_territory = f'''
        SELECT "Transport_Zone_name", SUM("Delivery_value") as revenue, COUNT(*) as orders
        FROM delivery_data
        WHERE "Transport_Zone_name" IS NOT NULL
        {unit_filter_clause}
        {month_filter}
        GROUP BY "Transport_Zone_name"
        ORDER BY revenue DESC
        '''
        territory_result = eval(db.run(query_territory))
        
        territories = []
        for row in territory_result:
            territories.append({
                "name": row[0],
                "revenue": float(row[1]),
                "orders": row[2]
            })

        # 2. Customers/Dealers (All, ordered by revenue)
        query_customer = f'''
        SELECT "Customer_Name", SUM("Delivery_value") as revenue, "Transport_Zone_name"
        FROM delivery_data
        WHERE "Customer_Name" IS NOT NULL
        {unit_filter_clause}
        {month_filter}
        GROUP BY "Customer_Name", "Transport_Zone_name"
        ORDER BY revenue DESC
        '''
        customer_result = eval(db.run(query_customer))
        
        customers = []
        for row in customer_result:
            customers.append({
                "name": row[0],
                "revenue": float(row[1]),
                "territory": row[2] if row[2] else "N/A"
            })
            
        if not territories and not customers:
             # Return empty structure meant for charts/lists, not 404 to avoid breaking UI entirely
             return {
                "top_territories": [],
                "bottom_territories": [],
                "top_dealers": [],
                "bottom_dealers": [],
                "ai_insights": "No data available for the selected period."
            }

        # Top 5 and Bottom 5
        top_territories = territories[:5]
        bottom_territories = territories[-5:] if len(territories) >= 5 else []
        # Reverse bottom list to show lowest first
        bottom_territories = bottom_territories[::-1]

        top_dealers = customers[:5]
        bottom_dealers = customers[-5:] if len(customers) >= 5 else []
        bottom_dealers = bottom_dealers[::-1]
        
        # Generate AI insights
        core = get_core()
        
        if territories and customers:
            top_terr = territories[0]
            low_terr = territories[-1] 
            top_cust = customers[0]
            ai_insights = core.analyze_territory_performance(top_terr, low_terr, top_cust)
        else:
            ai_insights = "Insufficient data for full analysis."
        
        return {
            "top_territories": top_territories,
            "bottom_territories": bottom_territories,
            "top_dealers": top_dealers,
            "bottom_dealers": bottom_dealers,
            "ai_insights": ai_insights
        }

    except Exception as e:
        print(f"Error in territory performance: {str(e)}")
        return {
            "top_territories": [],
            "bottom_territories": [],
            "top_dealers": [],
            "bottom_dealers": [],
            "ai_insights": "Error retrieving territory performance."
        }

@router.get("/v1/forecast")
def get_sales_forecast(unit_id: str = None):
    """Get sales forecast data with AI insights and comparative charts."""
    from db.engine import db
    import datetime
    
    try:
        unit_filter_delivery = f" AND \"Unit_ID\" = '{unit_id}'" if unit_id else ""
        unit_filter_ail = f" AND \"Unit_Id\" = '{unit_id}'" if unit_id else ""
        
        # Helper to merge actual and forecast
        def merge_data(actual_rows, forecast_rows):
            data_map = {}
            # Process Actuals
            for row in actual_rows:
                m, qty = row[0], float(row[1])
                data_map[m] = {"month": m, "actual": qty, "forecast": None}
            # Process Forecasts
            for row in forecast_rows:
                m, qty = row[0], float(row[1])
                if m in data_map:
                    data_map[m]["forecast"] = qty # Overlap if any
                else:
                    data_map[m] = {"month": m, "actual": None, "forecast": qty}
            
            # Sort by month
            sorted_keys = sorted(data_map.keys())
            return [data_map[k] for k in sorted_keys]

        # 1. Global Chart
        # Global Actuals (Historical)
        q_global_act = f'''
         SELECT 
            TO_CHAR("Date", 'YYYY-MM') AS month,
            SUM("numDeliveryQtyMT") AS total_qty
            FROM "AIL_Monthly_Total_Forecast"
            WHERE "Type" = 'Historical'
            {unit_filter_ail}
            AND "Date" >= date_trunc('month', CURRENT_DATE) - INTERVAL '10 months'
            GROUP BY month
            ORDER BY month DESC;
        '''
        # Global Forecast
        q_global_for = f'''
         SELECT 
            TO_CHAR("Date", 'YYYY-MM') AS month,
            SUM("numDeliveryQtyMT") AS total_qty
            FROM "AIL_Monthly_Total_Forecast"
            WHERE "Type" = 'Forecasted'
            {unit_filter_ail}
            AND "Date" >= date_trunc('month', CURRENT_DATE)
            AND "Date" <  date_trunc('month', CURRENT_DATE) + INTERVAL '5 months'
            GROUP BY month
            ORDER BY month;
        '''
        try:
            raw_act = db.run(q_global_act)
            if not raw_act: raw_act = "[]"
            res_act = eval(raw_act)
            res_act.reverse()

            raw_for = db.run(q_global_for)
            if not raw_for: raw_for = "[]"
            res_for = eval(raw_for)
            res_for.reverse()
        except Exception as e:
            print(f"Global Forecast Query Error: {e}")
            res_act = []
            res_for = []

        global_chart = merge_data(res_act, res_for)
        total_forecast_summary = [{"month": r[0], "qty": float(r[1])} for r in res_for]

        # 2. Items Charts (All Forecasted Items)
        q_top_items = f'''
        SELECT "Item_Name" FROM "AIL_Monthly_Total_Item" 
        WHERE "Type" = 'Forecasted'
        {unit_filter_ail}
        ORDER BY "numDeliveryQtyMT" DESC LIMIT 100
        '''
        try:
             raw_top_items = db.run(q_top_items)
             if not raw_top_items: raw_top_items = "[]"
             top_items_res = eval(raw_top_items)
             # Deduplicate names if any
             top_item_names = list(dict.fromkeys([r[0] for r in top_items_res])) if top_items_res else []
        except Exception as e:
             print(f"Error fetching top items: {e}")
             top_item_names = []
        
        items_charts = []
        for i_name in top_item_names:
            try:
                i_name_esc = i_name.replace("'", "''")
                # Item Actuals (Historical)
                q_i_act = f'''
                SELECT TO_CHAR("Date", 'YYYY-MM') as month, SUM("numDeliveryQtyMT")
                FROM "AIL_Monthly_Total_Item"
                WHERE "Item_Name" = '{i_name_esc}' AND "Type" = 'Historical'
                {unit_filter_ail}
                GROUP BY month ORDER BY month DESC LIMIT 6
                '''
                # Item Forecast
                q_i_for = f'''
                SELECT TO_CHAR("Date", 'YYYY-MM') as month, SUM("numDeliveryQtyMT")
                FROM "AIL_Monthly_Total_Item"
                WHERE "Item_Name" = '{i_name_esc}' AND "Type" = 'Forecasted'
                {unit_filter_ail}
                GROUP BY month ORDER BY month DESC LIMIT 6
                '''
                
                # Debug Execution
                try:
                    raw_i_act = db.run(q_i_act)
                    if not raw_i_act: raw_i_act = "[]"
                    res_i_act = eval(raw_i_act)
                except Exception as e:
                    print(f"DEBUG SQL FAIL ITEM ACT: {q_i_act}\nOUT: {raw_i_act if 'raw_i_act' in locals() else 'None'}")
                    raise e

                try:
                    raw_i_for = db.run(q_i_for)
                    if not raw_i_for: raw_i_for = "[]"
                    res_i_for = eval(raw_i_for)
                except Exception as e:
                     print(f"DEBUG SQL FAIL ITEM FOR: {q_i_for}\nOUT: {raw_i_for if 'raw_i_for' in locals() else 'None'}")
                     raise e

                res_i_act.reverse() # Chronological
                res_i_for.reverse()
                chart_data = merge_data(res_i_act, res_i_for)
                items_charts.append({"name": i_name, "chart": chart_data})
            except Exception as e:
                print(f"Error generating chart for item {i_name}: {e}")
                continue

        # 3. Territories Charts (All Forecasted Territories)
        q_top_terrs = f'''
        SELECT "Territory" FROM "AIL_Monthly_Total_Final_Territory"
        WHERE "Type" = 'Forecasted'
        {unit_filter_ail}
        ORDER BY "numDeliveryQtyMT" DESC LIMIT 100
        '''
        try:
             raw_top_terrs = db.run(q_top_terrs)
             if not raw_top_terrs: raw_top_terrs = "[]"
             top_terrs_res = eval(raw_top_terrs)
             top_terr_names = list(dict.fromkeys([r[0] for r in top_terrs_res])) if top_terrs_res else []
        except Exception as e:
             print(f"Error fetching top territories: {e}")
             top_terr_names = []

        territories_charts = []
        for t_name in top_terr_names:
             try:
                 t_name_esc = t_name.replace("'", "''")
                 # Territory Actuals (Historical)
                 q_t_act = f'''
                 SELECT TO_CHAR("Date", 'YYYY-MM') as month, SUM("numDeliveryQtyMT")
                 FROM "AIL_Monthly_Total_Final_Territory"
                 WHERE "Territory" = '{t_name_esc}' AND "Type" = 'Historical'
                 {unit_filter_ail}
                 GROUP BY month ORDER BY month DESC LIMIT 6
                 '''
                 # Territory Forecast
                 q_t_for = f'''
                 SELECT TO_CHAR("Date", 'YYYY-MM') as month, SUM("numDeliveryQtyMT")
                 FROM "AIL_Monthly_Total_Final_Territory"
                 WHERE "Territory" = '{t_name_esc}' AND "Type" = 'Forecasted'
                 {unit_filter_ail}
                 GROUP BY month ORDER BY month DESC LIMIT 6
                 '''
                 
                 # Debug Execution
                 try:
                    raw_t_act = db.run(q_t_act)
                    if not raw_t_act: raw_t_act = "[]"
                    res_t_act = eval(raw_t_act)
                 except Exception as e:
                    print(f"DEBUG SQL FAIL TERR ACT: {q_t_act}\nOUT: {raw_t_act if 'raw_t_act' in locals() else 'None'}")
                    raise e
                 
                 try:
                    raw_t_for = db.run(q_t_for)
                    if not raw_t_for: raw_t_for = "[]"
                    res_t_for = eval(raw_t_for)
                 except Exception as e:
                    print(f"DEBUG SQL FAIL TERR FOR: {q_t_for}\nOUT: {raw_t_for if 'raw_t_for' in locals() else 'None'}")
                    raise e

                 res_t_act.reverse()
                 res_t_for.reverse()
                 chart_data = merge_data(res_t_act, res_t_for)
                 territories_charts.append({"name": t_name, "chart": chart_data})
             except Exception as e:
                 print(f"Error generating chart for territory {t_name}: {e}")
                 continue

        # Summary Lists for AI - Calculate actual totals from the chart data
        top_items_summary = []
        for ic in items_charts[:5]: # Top 5 items
            total_forecast = sum(d["forecast"] or 0 for d in ic["chart"] if d["forecast"] is not None)
            top_items_summary.append({"name": ic["name"], "qty": total_forecast})

        top_terrs_summary = []
        for tc in territories_charts[:5]: # Top 5 territories
            total_forecast = sum(d["forecast"] or 0 for d in tc["chart"] if d["forecast"] is not None)
            top_terrs_summary.append({"name": tc["name"], "qty": total_forecast})

        # Generate AI insights
        core = get_core()
        ai_insights = core.analyze_forecast(total_forecast_summary, top_items_summary, top_terrs_summary)
        
        return {
            "global_chart": global_chart,
            "items_charts": items_charts,
            "territories_charts": territories_charts,
            "ai_insights": ai_insights
        }

        # Top Territories List
        q_terr_list = '''
        SELECT "Territory", SUM("numDeliveryQtyMT") as qty
        FROM "AIL_Monthly_Total_Final_Territory"
        WHERE "Date" >= CURRENT_DATE
        GROUP BY "Territory" ORDER BY qty DESC LIMIT 3
        '''
        try:
             res_terr_list = eval(db.run(q_terr_list))
             top_territories = [{"name": r[0], "qty": float(r[1])} for r in res_terr_list]
        except:
             top_territories = []

        # Generate AI insights
        core = get_core()
        ai_insights = core.analyze_forecast(total_forecast_summary, top_items, top_territories)
        
        return {
            "global_chart": global_chart,
            "item_chart": item_chart,
            "territory_chart": territory_chart,
            "top_item_name": top_item_name,
            "top_territory_name": top_terr_name,
            "ai_insights": ai_insights
        }

    except Exception as e:
        print(f"Forecast Error: {e}")
        return {
            "global_chart": [],
            "item_chart": [],
            "territory_chart": [],
            "ai_insights": {"trend": "Unknown", "analysis": "Forecast data not available."}
        }
